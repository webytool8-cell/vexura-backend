import { NextResponse } from 'next/server';
import { createMarketplaceListing, updatePinterestInfo } from '@/lib/database/marketplace';
import { enrichMetadataFromJSON } from '@/lib/automation/metadata-enricher';
import { validateAndFixIcon, calculateQualityScore } from '@/lib/validators/icon-validator';
import { postToPinterest } from '@/lib/automation/pinterest-poster';

function shouldEnforceMonochrome(promptText?: string): boolean {
  if (!promptText) return false;
  return /\b(monochrome|monotone|black\s*(and|&)\s*white|grayscale|single\s*color)\b/i.test(promptText);
}

function isLikelyLocalPlaceholderVector(vectorData: any): boolean {
  const elements = Array.isArray(vectorData?.elements) ? vectorData.elements : [];
  if (elements.length < 3) return false;

  const ids = elements.map((e: any) => String(e?.id || ''));
  const hasBase = ids.some((id: string) => ['base-rect', 'base-circle', 'base-tri'].includes(id));
  const hasCenterAccent = ids.includes('center-accent');

  const patterned = ids.filter((id: string) => /^(geo-(circle|rect)-\d+|tech-el-\d+|nature-el-\d+)$/.test(id)).length;
  const supportedTypesOnly = elements.every((e: any) => ['rect', 'circle', 'polygon'].includes(e?.type));

  return hasBase && hasCenterAccent && patterned >= 1 && supportedTypesOnly;
}

export async function POST(request: Request) {
  try {
    const { vectorData, fileName, prompt } = await request.json();

    if (!vectorData) {
      return NextResponse.json(
        { error: 'Vector data is required' },
        { status: 400 }
      );
    }

    // Validate structure
    if (!vectorData.name || !vectorData.elements) {
      return NextResponse.json(
        { error: 'Invalid vector format. Must include "name" and "elements"' },
        { status: 400 }
      );
    }

    if (isLikelyLocalPlaceholderVector(vectorData)) {
      return NextResponse.json(
        {
          error: 'Rejected placeholder vector generated by local fallback pack. Use /api/automate/generate or /api/automate/batch outputs for marketplace quality.',
          code: 'PLACEHOLDER_VECTOR_REJECTED'
        },
        { status: 400 }
      );
    }

    const validation = validateAndFixIcon(vectorData, { enforceMonochrome: shouldEnforceMonochrome(prompt) });
    const score = calculateQualityScore(validation);

    if (validation.errors.length > 0) {
      return NextResponse.json(
        {
          error: 'Icon validation failed',
          errors: validation.errors,
          warnings: validation.warnings
        },
        { status: 400 }
      );
    }

    const fixedVector = validation.fixed;

    // Generate metadata
    const enriched = enrichMetadataFromJSON(fixedVector, fileName);

    // Add validation info
    enriched.validation = {
      score,
      warnings: validation.warnings,
      autoFixed: validation.warnings.length > 0
    };

    // Save to database
    const listing = await createMarketplaceListing(enriched);

    // Optional Pinterest auto-post for dashboard/manual uploads as well
    const shouldPostToPinterest = process.env.PINTEREST_AUTO_POST === 'true';

    if (shouldPostToPinterest) {
      const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'https://www.vexura.io';

      try {
        const pinResult = await postToPinterest({
          title: enriched.pinterest.title,
          description: enriched.pinterest.description,
          board: enriched.pinterest.board,
          imageUrl: `${baseUrl}/api/pinterest/image/${listing.slug}`,
          link: `${baseUrl}/marketplace/${listing.slug}`,
          altText: enriched.pinterest.altText
        });

        await updatePinterestInfo(listing.slug, pinResult.pinId, pinResult.pinUrl);
        console.log('✅ Manual upload posted to Pinterest:', pinResult.pinId);
      } catch (error) {
        // Keep upload success even if Pinterest fails.
        console.warn('⚠️ Manual upload Pinterest auto-post failed:', error);
      }
    }

    console.log('✅ Manual upload successful:', listing.slug);

    return NextResponse.json({
      success: true,
      slug: listing.slug,
      id: listing.id,
      score,
      warnings: validation.warnings,
      url: `${process.env.NEXT_PUBLIC_BASE_URL}/marketplace/${listing.slug}`
    });
  } catch (error: any) {
    console.error('Upload failed:', error);
    return NextResponse.json(
      { error: error.message || 'Upload failed' },
      { status: 500 }
    );
  }
}
